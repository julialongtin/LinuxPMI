[patch @num@/@total@] @name@ Official git repository

this patch corresponds to the current tab's git position

Index: linux/hpc/remote.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/hpc/remote.c	2006-09-28 15:02:18.000000000 +0200
@@ -0,0 +1,390 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/syscalls.h>
+#include <linux/pagemap.h>
+#include <hpc/protocol.h>
+#include <hpc/mig.h>
+#include <hpc/comm.h>
+#include <hpc/task.h>
+#include <hpc/arch.h>
+#include <hpc/prototype.h>
+#include <hpc/service.h>
+#include <hpc/hpc.h>
+#include <hpc/debug.h>
+
+
+NORET_TYPE void remote_disappear(void)
+{
+	do_exit(SIGKILL);
+	/*NOTREACHED*/
+}
+
+struct vm_operations_struct remote_inode_mmap =
+{
+	.nopage = filemap_nopage,
+};
+
+int remote_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	if (vma->vm_flags & VM_SHARED) {
+		printk(KERN_ERR "remote_file_mmap: VM_SHARED mmaping\n");
+		return -1;
+	}
+	vma->vm_ops = &remote_inode_mmap;
+	return 0;
+}
+
+int remote_readpage(struct file *file, struct page *page)
+{
+	int error;
+	void *kmpage;
+	struct omp_page_req m;
+
+	kmpage = kmap(page);
+
+	m.file = rfiles_inode_get_file(file->f_dentry->d_inode);
+	m.offset = page->index << PAGE_CACHE_SHIFT;
+
+	error = comm_send_hd(current->om.contact, REM_PAGE, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(current->om.contact, kmpage, PAGE_SIZE);
+	if (error < 0)
+		goto error;
+	
+	SetPageUptodate(page);
+	kunmap(page);
+	return 0;
+error:
+	OMBUG("error %d\n", error);
+	ClearPageUptodate(page);
+	SetPageError(page);
+	return error;
+}
+
+long remote_do_mmap(unsigned long addr, unsigned long len,
+		unsigned long prot, unsigned long flags,
+		unsigned long fd, unsigned long pgoff)
+{
+	struct omp_mmap_req m;
+	struct omp_mmap_ret r;
+	struct file *file;
+	long error;
+
+	m.addr = addr;
+	m.len = len;
+	m.prot = prot;
+	m.flags = flags;
+	m.fd = fd;
+	m.pgoff = pgoff;
+
+	error = comm_send_hd(current->om.contact, REM_MMAP, &m, sizeof(m));
+	if (error < 0)
+		goto out;
+
+	error = comm_recv(current->om.contact, &r, sizeof(r));
+	if (error < 0)
+		goto out;
+
+	file = task_rfiles_get(current, r.file, -1, r.isize);
+
+	down_write(&current->mm->mmap_sem);
+	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+out:
+	return error;
+}
+
+/**
+ * remote_wait - wait @expect packet from deputy
+ **/
+int remote_wait(task_t *p, int expect, void *data, int len)
+{
+	int error;
+	struct omp_req req;
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		goto comm_error;
+
+	if (req.type != expect) {
+		OMBUG("unexpected [%x] expecting [%x]\n", req.type, expect);
+		return -1;
+	}
+
+	if (req.dlen != len) {
+		OMBUG("unexpected size\n");
+		return -1;
+	}
+
+	error = comm_recv(p->om.contact, data, len);
+	if (error < 0)
+		goto comm_error;
+	return 0;
+comm_error:
+	OMBUG("unexpected error %d\n", error);
+	return -1;
+}
+
+static int remote_do_signal(task_t *p)
+{
+	struct omp_signal s;
+	unsigned long flags;
+	int error;
+
+	error = comm_recv(p->om.contact, &s, sizeof(s));
+	printk("received signal %d\n", s.signr);
+
+	spin_lock_irqsave(&p->sighand->siglock, flags);
+	error = __group_send_sig_info(s.signr, &s.siginfo, p);
+	spin_unlock_irqrestore(&p->sighand->siglock, flags);
+
+	return 0;
+}
+
+/**
+ * remote_do_comm - process a communication
+ **/
+int remote_do_comm(task_t *p)
+{
+	int error;
+	struct omp_req req;
+
+	error = comm_recv(p->om.contact, &req, sizeof(req));
+	if (error < 0)
+		goto fail;
+
+	switch (req.type) {
+	case DEP_SIGNAL:
+		error = remote_do_signal(p);
+		break;
+	case DEP_COMING_HOME:
+		printk("remote_do_comm(): got DEP_COMING_HOME\n");
+		error = task_remote_expel(p);
+		break;
+	default:
+		printk("remote_do_comm(): got default\n");
+		goto fail;
+	}
+
+	return 0;
+fail:
+	OMBUG("failed\n");
+	do_exit(-1);
+	return -1;
+}
+
+/**
+ * remote_do_syscall - process a remote syscall
+ * @n:		the syscall number
+ * @regs:	userspace registers
+ **/
+long remote_do_syscall(int n, struct pt_regs *regs)
+{
+	task_t *p = current;
+	struct omp_syscall_req s;
+	struct omp_syscall_ret r;
+	int error, i;
+
+	OMDEBUG_SYS(1, "[remote] remote syscall %d\n", n);
+
+	s.n = n;
+	for (i = 0; i < NR_MAX_SYSCALL_ARG; i++)
+		s.arg[i] = arch_get_sys_arg(i, regs);
+
+	error = comm_send_hd(p->om.contact, REM_SYSCALL, &s, sizeof(s));
+	if (error < 0)
+		goto error;
+
+	OMDEBUG_SYS(3, "[remote] waiting deputy answer\n");
+
+	error = remote_handle_user(p, REM_SYSCALL|REPLY);
+	if (error < 0)
+		goto error;
+
+	error = comm_recv(p->om.contact, &r, sizeof(r));
+	if (error < 0)
+		goto error;
+
+	OMDEBUG_SYS(2, "[remote] sys[%d] = %ld\n", n, r.ret);
+
+	return r.ret;
+error:
+	remote_disappear();
+	return -1;
+}
+
+/**
+ * remote_do_fork - Fork a process on remote
+ **/
+long remote_do_fork(unsigned long clone_flags, unsigned long stack_start,
+	      struct pt_regs *regs, unsigned long stack_size,
+	      int __user *parent_tidptr, int __user *child_tidptr)
+{
+	task_t *child;
+	struct socket *childsock;
+	struct omp_fork_req m;
+	struct omp_fork_ret r;
+	int error, ret;
+	struct sockaddr sa;
+
+	printk(KERN_ERR "[REMOTE] do_fork\n");
+
+	sockaddr_inherit(current->om.contact, &sa);
+
+	m.clone_flags = clone_flags;
+	m.stack_start = stack_start;
+	m.stack_size = stack_size;
+	memcpy(&m.regs, regs, sizeof(struct pt_regs));
+
+	childsock = comm_setup_listen(&sa);
+	if (!childsock)
+		goto fail;
+
+	if (comm_getname(childsock, &sa, 0) < 0)
+		goto fail;
+
+	memcpy(&m.sockaddr, &sa, sizeof(struct sockaddr));
+
+	error = comm_send_hd(current->om.contact, REM_FORK, &m, sizeof(m));
+	if (error < 0)
+		goto fail;
+
+	ret = remote_wait(current, REM_FORK | REPLY, &r, sizeof(r));
+	if (ret < 0)
+		goto fail;
+	ret = do_fork(clone_flags, stack_start, regs, stack_size, parent_tidptr,
+								child_tidptr);
+	child = find_task_by_pid(ret);
+	if (!child) {
+		printk(KERN_ERR "error: child %d not found\n", r.pid);
+		return -1;
+	}
+	task_set_comm(child, childsock);
+
+	return ret;
+fail:
+	OMBUG("failed\n");
+	return -1;
+}
+
+/*
+ * this is a copy of count in fs/exec.c
+ */
+static int count_len(char __user * __user * argv, int max, int *len)
+{
+	int i = 0;
+
+	*len = 0;
+	if (!argv)
+		return 0;
+
+	for (;;) {
+		char __user * p;
+
+		if (get_user(p, argv))
+			return -EFAULT;
+		if (!p)
+			break;
+		*len += strlen_user(*argv);
+		argv++;
+		if (++i > max)
+			return -E2BIG;
+	}
+	return i;
+}
+
+/**
+ * remote_do_execve - do an execve syscall
+ **/
+long remote_do_execve(char __user * filename, char __user *__user *argv,
+		char __user *__user *envp, struct pt_regs * regs)
+{
+	struct omp_execve_req m;
+	struct omp_execve_ret r;
+	unsigned long p;
+	char *data, *ptr;
+	int error;
+	int sz;
+
+	p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);
+	//m.filename = filename;
+
+	m.filelen = strlen_user(filename);
+
+	error = m.argc = count_len(argv, p / sizeof(void *), &m.argvlen);
+	if (error < 0)
+		goto error;
+
+	error = m.envc = count_len(envp, p / sizeof(void *), &m.envplen);
+	if (error < 0)
+		goto error;
+
+	memcpy(&m.regs, regs, sizeof(struct pt_regs));
+
+	/* pack all data (filename, argv, envp) */
+	sz = m.filelen + m.argvlen + m.envplen + 3;
+	data = kmalloc(sz, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	error = -EFAULT;
+
+	ptr = data;
+	if (copy_from_user(ptr, filename, m.filelen))
+		goto error;
+	ptr += m.filelen;
+	*ptr++ = '\0';
+
+	if (copy_from_user(ptr, argv, m.argvlen))
+		goto error;
+	ptr += m.argvlen;
+	*ptr++ = '\0';
+
+	if (copy_from_user(ptr, envp, m.envplen))
+		goto error;
+	ptr += m.envplen;
+	*ptr++ = '\0';
+
+	/* send request */
+	error = comm_send_hd(current->om.contact, REM_EXECVE, &m, sizeof(m));
+	if (error < 0)
+		goto error;
+
+	/* send packed data */
+	error = comm_send(current->om.contact, data, sz);
+	kfree(data);
+	if (error < 0)
+		goto error;
+
+	error = remote_wait(current, REM_EXECVE | REPLY, &r, sizeof(r));
+	if (error < 0)
+		goto error;
+
+	return 0;
+error:
+	return error;
+}
Index: linux/hpc/service.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/hpc/service.c	2006-09-28 15:02:18.000000000 +0200
@@ -0,0 +1,153 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <hpc/comm.h>
+#include <hpc/comm-ipv4.h>
+#include <hpc/comm-ipv6.h>
+#include <hpc/service.h>
+#include <hpc/task.h>
+#include <hpc/arch.h>
+
+/**
+ * om_daemonize - create an oM daemon
+ * @name:	kernel thread name
+ * @highpri:	is this kernel thread high priority
+ *
+ * Description:
+ *	Create a kernel thread, and set priority.
+ *	SCHED_FIFO for high priority, hence stay for realtime
+ **/
+void om_daemonize(char *name, int highpri)
+{
+	task_t *p = current;
+
+	daemonize(name);
+
+	p->euid = 0;
+	p->suid = 0;
+	p->gid = 0;
+	p->group_info = groups_alloc(0);
+
+	/* clean blocked signal set */
+	spin_lock_irq(&p->sighand->siglock);
+	sigemptyset(&p->blocked);
+	recalc_sigpending_tsk(p);
+	spin_unlock_irq(&p->sighand->siglock);
+
+	/* set priority and stay reason of the task */
+	task_lock(p);
+	if (highpri)
+	{
+		p->policy = SCHED_FIFO;
+		task_set_stay(p, DSTAY_RT);
+		p->rt_priority = 0;
+	}
+	else
+	{
+		p->policy = SCHED_NORMAL;
+		task_clear_stay(p, DSTAY_RT);
+		set_user_nice(p, 0);
+	}
+	task_set_stay(p, DSTAY_SYSTEM);
+	task_unlock(p);
+}
+
+/**
+ * sockaddr_to_string - write an net address to a buffer returning length
+ **/
+int sockaddr_to_string(struct sockaddr *address, char *buf)
+{
+	switch (address->sa_family) {
+	case AF_INET:
+		return inet_to_string((struct sockaddr_in *) address, buf);
+	case AF_INET6:
+		return inet6_to_string((struct sockaddr_in6 *) address, buf);
+	}
+	printk(KERN_ERR "oM: network type not supported\n");
+	return 0;
+}
+
+
+/**
+ * string_to_sockaddr - convert a buffer, to a sockaddr
+ **/
+int string_to_sockaddr(char *buf, struct sockaddr *address)
+{
+	int l;
+
+	address->sa_family = 0;
+	/* try to parse an ipv4 */
+	l = string_to_inet(buf, (struct sockaddr_in *) address);
+	if (l > 0)
+		return l;
+	/* try to parse an ipv6 */
+	l = string_to_inet6(buf, (struct sockaddr_in6 *) address);
+	if (l > 0)
+		return l;
+	return 0;
+}
+
+/**
+ * sockaddr_setup - configure a socket address
+ **/
+void sockaddr_setup_port(struct sockaddr *sa, int port)
+{
+	switch (sa->sa_family) {
+	case AF_INET:
+		inet_setup_port((struct sockaddr_in *) sa, port);
+		break;
+	case AF_INET6:
+		inet6_setup_port((struct sockaddr_in6 *) sa, port);
+		break;
+	}
+}
+
+/**
+ * sockaddr_inherit - fullfill sa with the same type of mlink
+ **/
+int sockaddr_inherit(struct socket *mlink, struct sockaddr *sa)
+{
+	struct sockaddr tmp;
+
+	if (comm_getname(mlink, &tmp, 0) < 0)
+		return -1;
+
+	memset(sa, 0, sizeof(struct sockaddr));
+	sa->sa_family = tmp.sa_family;
+
+	switch (tmp.sa_family) {
+		case AF_INET: {
+			struct sockaddr_in *in = (struct sockaddr_in *) sa;
+			in->sin_addr.s_addr = INADDR_ANY;
+			break;
+		}
+		case AF_INET6: {
+			struct sockaddr_in6 *in6 = (struct sockaddr_in6 *) sa;
+			memset(&in6->sin6_addr, 0, sizeof(struct in6_addr));
+			break;
+		}
+	}
+	return 0;
+}
Index: linux/hpc/syscalls.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/hpc/syscalls.c	2006-09-28 15:02:18.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <linux/types.h>
+#include <asm/ptrace.h>
+#include <asm/unistd.h>
+#include <hpc/prototype.h>
+#include <hpc/arch.h>
+#include <hpc/syscalls.h>
+#include <hpc/debug.h>
+#include <hpc/hpc.h>
+
+/* generic multiplexer */
+asmlinkage long om_sys_local(struct pt_regs regs)
+{
+	long ret;
+
+	OMDEBUG_SYS(1, "[remote] local syscall %d\n", SYSNB());
+
+	ret = arch_exec_syscall(SYSNB(), (syscall_parameter_t *) &regs);
+	return ret;
+}
+
+asmlinkage long om_sys_remote(struct pt_regs regs)
+{
+	return remote_do_syscall(SYSNB(), &regs);
+}
+
+/* specific remote syscalls */
+asmlinkage int om_sys_gettid(struct pt_regs regs)
+{
+	return current->om.pid;
+}
+
+asmlinkage int om_sys_getpid(struct pt_regs regs)
+{
+	return current->om.tgid;
+}
+
+asmlinkage int om_sys_execve(struct pt_regs regs)
+{
+	return remote_do_execve((char __user *) SYSARG(0),
+	                        (char __user *__user *) SYSARG(1),
+	                        (char __user *__user *) SYSARG(2),
+	                        &regs);
+}
Index: linux/hpc/task.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/hpc/task.c	2006-09-28 15:02:18.000000000 +0200
@@ -0,0 +1,223 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <hpc/task.h>
+#include <hpc/comm.h>
+#include <hpc/mig.h>
+#include <hpc/prototype.h>
+#include <hpc/hpc.h>
+
+/**
+ * task_set_comm - swap openMosix link for a process (return old one)
+ * @p:		task to swap link
+ * @mlink:	new openMosix link
+ *
+ * Description:
+ *	Remove old link from task @p
+ *	Set @p socket to the new one @mlink
+ **/
+struct socket * task_set_comm(task_t *p, struct socket *mlink)
+{
+	struct socket *oldmlink;
+
+	oldmlink = p->om.contact;
+	p->om.contact = mlink;
+
+	if (mlink && test_bit(SOCK_OOB_IN, &mlink->flags))
+		task_set_dreqs(p, DREQ_URGENT);
+	return oldmlink;
+}
+
+/**
+ * task_file_check_stay - check if task should stay because of file mapping
+ **/
+static int task_file_check_stay(struct vm_area_struct *vma)
+{
+	struct inode *inode;
+	mode_t mode;
+	int stay = 0;
+
+	inode = vma->vm_file->f_dentry->d_inode;
+	if (!inode)
+		return 0;
+
+	mode = inode->i_mode;
+
+	/* FIXME Tab: maybe wrong */
+	if (!(vma->vm_flags & VM_NONLINEAR)) {
+		if (!prio_tree_empty(&inode->i_mapping->i_mmap))
+			stay |= DSTAY_MONKEY;
+	} else {
+		if (!list_empty(&vma->shared.vm_set.list))
+			stay |= DSTAY_MONKEY;
+	}
+	if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))
+		stay |= DSTAY_DEV;
+
+	return stay;
+}
+
+/**
+ * task_request_checkstay - adjust stay reason of a task (considering mm)
+ **/
+void task_request_checkstay(task_t *p)
+{
+	struct mm_struct *mm;
+	int stay;
+	struct vm_area_struct *vma;
+
+	task_clear_dreqs(p, DREQ_CHECKSTAY);
+
+	printk(KERN_ERR "oM: [%d] do_request: DREQ_CHECKSTAY\n", p->pid);
+
+	/* check if there's a stay reason we can clean, else pass */
+	if (!task_test_stay(p, DSTAY_PER_MM | DSTAY_CLONE))
+		return;
+
+	task_lock(p);
+	mm = p->mm;
+	stay = p->om.stay & ~(DSTAY_PER_MM | DSTAY_CLONE);
+	if (!mm)
+		stay |= DSTAY_CLONE;
+	else {
+		/* FIXME: need verifying KIOBUF */
+		if (atomic_read(&mm->mm_realusers) > 1)
+			stay |= DSTAY_CLONE;
+		if (mm->def_flags & VM_LOCKED)
+			stay |= DSTAY_MLOCK;
+
+		for (vma = mm->mmap; vma; vma = vma->vm_next)
+		{
+			if (vma->vm_file)
+				stay |= task_file_check_stay(vma);
+			if (vma->vm_flags & VM_LOCKED)
+				stay |= DSTAY_MLOCK;
+		}
+	}
+	if (p->om.stay != stay)
+		p->om.stay = stay;
+	task_unlock(p);
+	return;
+}
+
+/**
+ * task_request_move - move a task
+ **/
+void task_request_move(task_t *p)
+{
+	struct sockaddr *addr;
+
+	task_clear_dreqs(p, DREQ_MOVE);
+	addr = p->om.whereto;
+	p->om.whereto = NULL;
+
+	task_move_to_node(p, addr, 0);
+	kfree(addr);
+}
+
+/**
+ * openmosix_task_init - Init all openMosix structure of a task @p
+ **/
+int openmosix_task_init(task_t *p)
+{
+	task_t *parent = current;
+
+	memset(&p->om, 0, sizeof(om_task_t));
+	
+	if (p->pid == 1)
+		task_set_stay(p, DSTAY_SYSTEM);
+
+	/* if father of task is a DREMOTEDAEMON, then the task is DREMOTE */
+	if (task_test_dflags(parent, DREMOTEDAEMON))
+		task_set_dflags(p, DREMOTE);
+	/* child of a DDEPUTY is a DDEPUTY */
+	if (task_test_dflags(parent, DDEPUTY))
+		task_set_dflags(p, DDEPUTY);
+
+	INIT_LIST_HEAD(&p->om.rfiles);
+	
+	return 0;
+}
+
+/**
+ * openmosix_task_exit - Exit current task
+ **/
+int openmosix_task_exit(void)
+{
+	task_t *p = current;
+	
+	if (!task_test_dflags(p, DDEPUTY | DREMOTE))
+		return 0;
+
+	task_heldfiles_clear(p);
+	
+	if (p->om.contact)
+		comm_close(p->om.contact);
+	return 0;
+}
+
+/**
+ * task_wait_contact - wait until the process got a contact with deputy
+ **/
+static inline void task_wait_contact(task_t *p)
+{
+	DECLARE_WAITQUEUE(wait, p);
+
+	add_wait_queue(&p->om.wait_dist, &wait);
+	while (!p->om.contact)
+	{
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule();
+	}
+	remove_wait_queue(&p->om.wait_dist, &wait);
+	set_current_state(TASK_RUNNING);
+}
+
+/**
+ * task_register_migration - register a migration for this process
+ * @p:		task to migrate
+ * @dest:	destination of the migration (NULL == home)
+ **/
+int task_register_migration(task_t *p, struct sockaddr *dest)
+{
+	if (dest) {
+		p->om.whereto = kmalloc(sizeof(struct sockaddr), GFP_KERNEL);
+		if (!p->om.whereto)
+			return -1;
+		memcpy(p->om.whereto, dest, sizeof(struct sockaddr));
+	}
+	task_set_dreqs(p, DREQ_MOVE);
+	wake_up_process(p);
+	set_ti_thread_flag(p->thread_info, TIF_NEED_RESCHED);
+	return 0;
+}
+
+/**
+ * task_do_request - current task processes requests coming from other tasks
+ **/
+void task_do_request(void)
+{
+	if (task_test_dreqs(current, DREQ_MOVE))
+		task_request_move(current);
+	if (task_test_dreqs(current, DREQ_CHECKSTAY))
+		task_request_checkstay(current);
+}
Index: linux/include/asm-i386/om.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-i386/om.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+int cpu_feature_has_fxsr(void);
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	BUG_ON(n >= 6);
+	return *(((long *) regs) + n);
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return regs->eax;
+}
+
+#define NR_MAX_SYSCALL_ARG	6
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE - 8 +		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_X86 */
Index: linux/include/asm-i386/om-protocol.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-i386/om-protocol.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+
+#include <asm/i387.h>
+
+#define MIG_ARCH_I386_LDT	1
+
+struct omp_mig_fp
+{
+	int has_fxsr;
+	union i387_union data;
+};
+
+struct omp_mig_arch
+{
+	int type;
+};
+
+struct omp_mig_arch_task
+{
+	u32 features[NCAPINTS];
+	long debugreg[8];
+	long fs;
+	long gs;
+	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
+};
+
+#endif /*  _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_X86 */
Index: linux/include/asm-i386/uaccess.h
===================================================================
--- linux.orig/include/asm-i386/uaccess.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/asm-i386/uaccess.h	2006-09-28 15:02:19.000000000 +0200
@@ -34,6 +34,8 @@
 
 #define segment_eq(a,b)	((a).seg == (b).seg)
 
+#include <hpc/uaccess.h>
+
 /*
  * movsl can be slow when source and dest are not both 8-byte aligned
  */
@@ -150,6 +152,10 @@
 ({	int __ret_gu;							\
 	unsigned long __val_gu;						\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		__ret_gu = deputy_get_user((long *) &__val_gu, ptr,	\
+						sizeof (*(ptr)));	\
+ 	} else 								\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
@@ -196,10 +202,17 @@
 #ifdef CONFIG_X86_WP_WORKS_OK
 
 #define put_user(x,ptr)						\
-({	int __ret_pu;						\
+({	int __ret_pu = 0;					\
 	__typeof__(*(ptr)) __pu_val;				\
 	__chk_user_ptr(ptr);					\
 	__pu_val = x;						\
+	if (openmosix_memory_away() && sizeof(*(ptr)) <= 8) {	\
+		if (sizeof(*(ptr)) < 8)				\
+			__ret_pu = deputy_put_user((long) x, ptr, sizeof(*(ptr)));\
+		else						\
+			deputy_put_user64_helper((x),		\
+						ptr, __ret_pu);	\
+	} else							\
 	switch(sizeof(*(ptr))) {				\
 	case 1: __put_user_1(__pu_val, ptr); break;		\
 	case 2: __put_user_2(__pu_val, ptr); break;		\
@@ -216,6 +229,8 @@
  	int __ret_pu;						\
 	__typeof__(*(ptr)) __pus_tmp = x;			\
 	__ret_pu=0;						\
+	if (openmosix_memory_away())				\
+		return deputy_put_user(ptr, &__pus_tmp, sizeof(*(ptr))); \
 	if(unlikely(__copy_to_user_ll(ptr, &__pus_tmp,		\
 				sizeof(*(ptr))) != 0))		\
  		__ret_pu=-EFAULT;				\
@@ -296,12 +311,32 @@
 		: "=r"(err)					\
 		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
 
-#ifdef CONFIG_X86_WP_WORKS_OK
+#ifdef CONFIG_OPENMOSIX
+#define deputy_put_user64_helper(x, addr, ret)			\
+	__asm__ __volatile__(					\
+		"1: pushl %%eax\n"				\
+		"pushl %%edx\n"					\
+		"pushl %2\n"					\
+		"call deputy_put_user64\n"			\
+		"movl %%eax, %0\n"				\
+		"popl %%edx\n"					\
+		"popl %%eax\n"					\
+		: "=r"(ret)					\
+		: "A" (x), "r" (addr), "0"(ret))
+#endif
 
+#ifdef CONFIG_X86_WP_WORKS_OK
 #define __put_user_size(x,ptr,size,retval,errret)			\
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+	if (openmosix_memory_away() && size <= 8) {			\
+		if (size < 8)						\
+			retval = deputy_put_user((long) x, ptr, size);	\
+		else							\
+			deputy_put_user64_helper((__typeof__(*ptr))(x),	\
+						ptr, retval);		\
+	} else								\
 	switch (size) {							\
 	case 1: __put_user_asm(x,ptr,retval,"b","b","iq",errret);break;	\
 	case 2: __put_user_asm(x,ptr,retval,"w","w","ir",errret);break; \
@@ -318,6 +353,13 @@
 	__typeof__(*(ptr)) __pus_tmp = x;				\
 	retval = 0;							\
 									\
+	if (openmosix_memory_away() && size <= 8)			\
+		if (size < 8)						\
+			retval = deputy_put_user((long) x, ptr, size);	\
+		else							\
+			deputy_put_user64_helper((__typeof__(*ptr))(x),	\
+						ptr, retval);		\
+	else								\
 	if(unlikely(__copy_to_user_ll(ptr, &__pus_tmp, size) != 0))	\
 		retval = errret;					\
 } while (0)
@@ -362,6 +404,9 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		retval = deputy_get_user((long *) &x, ptr, size);	\
+ 	} else 								\
 	switch (size) {							\
 	case 1: __get_user_asm(x,ptr,retval,"b","b","=q",errret);break;	\
 	case 2: __get_user_asm(x,ptr,retval,"w","w","=r",errret);break;	\
@@ -416,6 +461,10 @@
 static __always_inline unsigned long __must_check
 __copy_to_user_inatomic(void __user *to, const void *from, unsigned long n)
 {
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_to_user(to, from, n);
+#endif
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -461,6 +510,10 @@
 static __always_inline unsigned long
 __copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)
 {
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_from_user(to, from, n);
+#endif
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -508,7 +561,15 @@
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
+#define strlen_user_local(str) strnlen_user(str, ~0UL >> 1)
+
+#ifdef CONFIG_OPENMOSIX
+#define strlen_user(str) (openmosix_memory_away())			\
+				? deputy_strnlen_user(str, 0)		\
+				: strlen_user_local(str)
+#else
+#define strlen_user(str) strlen_user_local(str)
+#endif
 
 long strnlen_user(const char __user *str, long n);
 unsigned long __must_check clear_user(void __user *mem, unsigned long len);
Index: linux/include/asm-ppc/om.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ppc/om.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_PPC
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	BUG_ON(n >= 31);
+	return regs->gpr[n + 1];
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return regs->gpr[0] >> 2;
+}
+
+#define NR_MAX_SYSCALL_ARG	7
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE +		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_PPC */
+
Index: linux/include/asm-ppc/om-protocol.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ppc/om-protocol.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_PPC
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+struct omp_mig_fp
+{
+	int has_altivec;
+	double fpr[32];
+	unsigned long fpscr_pad;
+	unsigned long fpscr;
+};
+
+struct omp_mig_arch
+{
+};
+
+struct omp_mig_arch_task
+{
+};
+
+#endif /* _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_PPC */
Index: linux/include/asm-x86_64/om.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-x86_64/om.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86_64
+#ifndef _HPC_ARCH_ARCH_H
+#define _HPC_ARCH_ARCH_H
+
+static inline long arch_get_sys_arg(unsigned int n, struct pt_regs *regs)
+{
+	switch (n) {
+		case 0: return regs->rdi;
+		case 1: return regs->rsi;
+		case 2: return regs->rdx;
+		case 3: return regs->rcx;
+		case 4: return regs->r8;
+		case 5: return regs->r9;
+		default: BUG();
+	}
+	return -1;
+}
+
+static inline int arch_get_sys_nb(struct pt_regs *regs)
+{
+	return (int) (regs->rax & 0xffffffff);
+}
+
+#define NR_MAX_SYSCALL_ARG	6
+
+#define ARCH_TASK_GET_USER_REGS(p)				\
+		(((struct pt_regs *) (THREAD_SIZE + 		\
+		(unsigned long) p->thread_info)) - 1)
+
+#endif /* _HPC_ARCH_ARCH_H */
+#endif /* CONFIG_X86_64 */
Index: linux/include/asm-x86_64/om-protocol.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-x86_64/om-protocol.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifdef CONFIG_X86_64
+#ifndef _HPC_ARCHPROTOCOL_H
+#define _HPC_ARCHPROTOCOL_H
+
+#include <asm/i387.h>
+
+struct omp_mig_fp
+{
+	union i387_union data;
+};
+
+struct omp_mig_arch
+{
+	int type;
+};
+
+struct omp_mig_arch_task
+{
+	unsigned long userrsp;
+	unsigned long fs;
+	unsigned long gs;
+	unsigned int es, ds, fsindex, gsindex;
+	u64 tls_array[GDT_ENTRY_TLS_ENTRIES];
+};
+
+#endif /*  _HPC_ARCHPROTOCOL_H */
+#endif /* CONFIG_X86_64 */
Index: linux/include/asm-x86_64/uaccess.h
===================================================================
--- linux.orig/include/asm-x86_64/uaccess.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/asm-x86_64/uaccess.h	2006-09-28 15:02:19.000000000 +0200
@@ -35,6 +35,8 @@
 
 #define __addr_ok(addr) (!((unsigned long)(addr) & (current_thread_info()->addr_limit.seg)))
 
+#include <hpc/uaccess.h>
+
 /*
  * Uhhuh, this needs 65-bit arithmetic. We have a carry..
  */
@@ -95,6 +97,9 @@
 ({	unsigned long __val_gu;						\
 	int __ret_gu; 							\
 	__chk_user_ptr(ptr);						\
+ 	if (openmosix_memory_away()) {					\
+ 		__ret_gu = deputy_get_user(&__val_gu, ptr, sizeof (*(ptr))); \
+ 	} else 								\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
@@ -155,6 +160,9 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+	if (openmosix_memory_away()) {					\
+		retval = deputy_put_user((long) x, ptr, size);		\
+	} else								\
 	switch (size) {							\
 	  case 1: __put_user_asm(x,ptr,retval,"b","b","iq",-EFAULT); break;\
 	  case 2: __put_user_asm(x,ptr,retval,"w","w","ir",-EFAULT); break;\
@@ -247,6 +255,10 @@
 static __always_inline int __copy_from_user(void *dst, const void __user *src, unsigned size)
 { 
        int ret = 0;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_from_user(dst, src, size);
+#endif
 	if (!__builtin_constant_p(size))
 		return copy_user_generic(dst,(__force void *)src,size);
 	switch (size) { 
@@ -276,6 +288,10 @@
 static __always_inline int __copy_to_user(void __user *dst, const void *src, unsigned size)
 { 
        int ret = 0;
+#ifdef CONFIG_OPENMOSIX
+	if (openmosix_memory_away())
+		return deputy_copy_to_user(dst, src, size);
+#endif
 	if (!__builtin_constant_p(size))
 		return copy_user_generic((__force void *)dst,src,size);
 	switch (size) { 
Index: linux/include/hpc/arch.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/arch.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_ARCH_H
+#define _HPC_ARCH_H
+
+#include <hpc/protocol.h>
+
+NORET_TYPE void arch_kickstart(struct task_struct *);
+int arch_mig_receive_proc_context(struct task_struct *, struct omp_mig_task *);
+void arch_mig_receive_fp(struct task_struct *, struct omp_mig_fp *);
+int arch_mig_receive_specific(struct task_struct *, struct omp_mig_arch *);
+
+void arch_mig_send_pre(struct task_struct *);
+void arch_mig_send_post(struct task_struct *);
+int arch_mig_send_fp(task_t *p, struct omp_mig_fp *);
+int arch_mig_send_proc_context(struct task_struct *, struct omp_mig_task *);
+int arch_mig_send_specific(struct task_struct *);
+
+#include <asm/om.h>
+#include <hpc/syscalls.h>
+
+long arch_exec_syscall(int, syscall_parameter_t *);
+
+#endif /* _HPC_ARCH_H */
Index: linux/include/hpc/comm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/comm.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_H
+#define _HPC_COMM_H
+
+#include <net/sock.h>
+#include <hpc/protocol.h>
+
+/* this was put in include/linux/net.h ..., me no like */
+#define	SOCK_INTER_OPENMOSIX	3	/* used internally in kernel-mode */
+#define	SOCK_OOB_IN		5	/* OOB received on openmosix socket */
+
+/* node-disconnection timeout: */
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_INTERVAL	30
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_MAXTRIES	6
+#define	OPENMOSIX_CONNECTION_KEEPALIVE_TOTAL	150 /* changed from 180 */
+
+#define COMM_REMOTE_TIMO	(200L * HZ)
+#define COMM_CONNECT_TIMO	(4L * HZ)
+#define COMM_RECONN_TIMO	(10L * HZ)
+
+/* the ports we use */
+#define MIG_DAEMON_PORT		0x3412
+
+/* external variables that need to be available */
+extern unsigned long comm_remote_timo;
+extern unsigned long comm_connect_timo;
+extern unsigned long comm_reconn_timo;
+
+/* routines inside comm.c */
+void comm_data_ready(struct sock *, int);
+struct socket * comm_socket(int, int, int);
+int comm_bind(struct socket *, struct sockaddr *);
+int comm_peek(struct socket *);
+void comm_close(struct socket *);
+int comm_wait(struct socket *);
+int comm_connect(struct socket *, struct sockaddr *, unsigned long);
+int comm_accept(struct socket *, struct socket **, struct sockaddr *, unsigned long);
+int comm_recv(struct socket *, void *, int);
+int comm_send(struct socket *, void *, int);
+int comm_getname(struct socket *, struct sockaddr *, int);
+
+void set_our_addr(int, struct sockaddr *, int);
+struct socket * comm_setup_listen(struct sockaddr *);
+struct socket * comm_setup_connect(struct sockaddr *, int);
+int comm_send_hd(struct socket *, int, void *, int);
+int comm_send_req(struct socket *link, int type);
+
+/* FIXME: oM task routines, this really should be in task.h,
+ * but it causes problems there */
+struct socket * task_set_comm(task_t *, struct socket *);
+
+#endif /* _HPC_COMM_H */
Index: linux/include/hpc/comm-ipv4.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/comm-ipv4.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_IPV4_H
+#define _HPC_COMM_IPV4_H
+
+#ifdef CONFIG_INET
+#include <linux/in.h>
+
+inline int inet_to_string(struct sockaddr_in *address, char *buffer)
+{
+	return sprintf(buffer, "%u.%u.%u.%u",
+			NIPQUAD(address->sin_addr.s_addr));
+}
+
+int string_to_inet(char *buf, struct sockaddr_in *address)
+{
+	u32 iaddr;
+	unsigned int arr[4], ret;
+	char *endbuf;
+
+	ret = sscanf(buf, "%u.%u.%u.%u", &arr[0], &arr[1], &arr[2], &arr[3]);
+	if (ret != 4 || !(arr[0] < 256 && arr[1] < 256
+			&& arr[2] < 256 && arr[3] < 256))
+		return 0;
+	iaddr = (arr[0] << 24) + (arr[1] << 16) + (arr[2] << 8) + arr[3];
+	address->sin_addr.s_addr = htonl(iaddr);
+
+	endbuf = buf;
+	while (*endbuf && (*endbuf == '.' || (isdigit(*endbuf))))
+		endbuf++;
+	address->sin_family = AF_INET;
+	return endbuf - buf;
+}
+
+void inet_setup_port(struct sockaddr_in *sa_in, u16 port)
+{
+	sa_in->sin_port = port;
+}
+
+#else
+
+#endif /* CONFIG_INET */
+#endif /* _HPC_COMM_IPV4_H */
Index: linux/include/hpc/comm-ipv6.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/comm-ipv6.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,67 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_COMM_IPV6_H
+#define _HPC_COMM_IPV6_H
+
+#ifdef CONFIG_IPV6
+
+#include <linux/in6.h>
+
+inline int inet6_to_string(struct sockaddr_in6 *address, char *buffer)
+{
+	return sprintf(buffer, "%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x",
+			NIP6(address->sin6_addr));
+}
+
+
+int string_to_inet6(char *buf, struct sockaddr_in6 *address)
+{
+	char *endbuf;
+	int arr[8], ret;
+
+	ret = sscanf(buf, "%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x",
+			&arr[0], &arr[1], &arr[2], &arr[3],
+			&arr[4], &arr[5], &arr[6], &arr[7]);
+	if (ret != 8)
+		return 0;
+
+	for (ret = 0; ret < 8; ret++)
+		address->sin6_addr.s6_addr16[ret] = htons(arr[ret]);
+
+	endbuf = buf;
+	while (*endbuf && (*endbuf == ':' || (isxdigit(*endbuf))))
+		endbuf++;
+	address->sin6_family = AF_INET6;
+	return endbuf - buf;
+}
+
+inline void inet6_setup_port(struct sockaddr_in6 *sa_in6, u16 port)
+{
+	sa_in6->sin6_port = port;
+}
+
+#else
+
+#define inet6_to_string(s, c)		-1
+#define string_to_inet6(str, s)		-1
+#define inet6_setup_port(s, i)
+
+#endif /* CONFIG_IPV6 */
+#endif /* _HPC_COMM_IPV6_H */
Index: linux/include/hpc/debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/debug.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_DEBUG_H
+#define _HPC_DEBUG_H
+
+#include <hpc/protocol.h>
+#include <hpc/comm.h>
+#include <hpc/hpc.h>
+
+int proc_debug_get_loadinfo(char *value, size_t size);
+int proc_debug_get_admin(char *value, size_t size);
+
+int proc_debug_get_lfree_mem(char *value, size_t size);
+int proc_debug_get_pkeep_free(char *value, size_t size);
+
+int proc_debug_get_nodes(char *value, size_t size);
+
+
+/* for packets */
+void om_debug_regs(struct pt_regs *);
+void debug_mlink(struct socket *);
+
+void debug_page(unsigned long);
+void debug_regs(void);
+void debug_vmas(struct mm_struct *);
+
+#ifdef CONFIG_OPENMOSIX_DEBUG
+#define OMDEBUG(var, lim, fmt...)	{ if (var >= lim) \
+					printk(KERN_DEBUG "[OMDBG] " fmt); }
+#else
+#define OMDEBUG(var, lim, fmt...)	do {} while (0)
+#endif
+
+#define OMDEBUG_MIG(lim, fmt...)	OMDEBUG(om_opts.debug_mig, lim, fmt)
+#define OMDEBUG_SYS(lim, fmt...)	OMDEBUG(om_opts.debug_sys, lim, fmt)
+#define OMDEBUG_RINO(lim, fmt...)	OMDEBUG(om_opts.debug_rino, lim, fmt)
+#define OMDEBUG_CPYUSER(lim, fmt...)	OMDEBUG(om_opts.debug_copyuser, lim, fmt)
+
+#endif /* _HPC_DEBUG_H */
Index: linux/include/hpc/hpc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/hpc.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_HPC_H
+#define _HPC_HPC_H
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+
+/* arch specific */
+int user_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/* init.c */
+void info_startup(void);
+
+/* proc.c */
+int openmosix_proc_pid_getattr(struct task_struct *, char *, void *, size_t);
+int openmosix_proc_pid_setattr(struct task_struct *, char *, void *, size_t);
+void openmosix_proc_init(void);
+
+/* kernel.c */
+int openmosix_pre_clone(int);
+void openmosix_post_clone(int);
+
+int stay_me_and_my_clones(int);
+void openmosix_no_longer_monkey(struct inode *);
+void unstay_mm(struct mm_struct *);
+
+int obtain_mm(task_t *p);
+
+/* task.c */
+int openmosix_task_init(struct task_struct *);
+int openmosix_task_exit(void);
+
+struct openmosix_options
+{
+#ifdef CONFIG_OPENMOSIX_DEBUG
+	int debug_mig;
+	int debug_sys;
+	int debug_rino;
+	int debug_copyuser;
+#endif
+};
+
+extern struct openmosix_options om_opts;
+
+unsigned long	deputy_do_mmap_pgoff(struct file * file, unsigned long addr,
+				unsigned long len, unsigned long prot,
+				unsigned long flags, unsigned long pgoff);
+long		remote_do_mmap(unsigned long addr, unsigned long len,
+				unsigned long prot, unsigned long flags,
+				unsigned long fd, unsigned long pgoff);
+long		remote_do_execve(char __user * filename,
+				char __user *__user *argv,
+				char __user *__user *envp,
+				struct pt_regs * regs);
+
+#endif /* _HPC_HPC_H */
Index: linux/include/hpc/mig.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/mig.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_MIG_H
+#define _HPC_MIG_H
+
+#include <linux/sched.h>
+#include <net/sock.h>
+#include <hpc/comm.h>
+
+#define REMOTE_DAEMON_PORT  0x3412
+
+/* PROTOTYPES */
+int openmosix_mig_daemon(void *);
+
+int mig_do_receive(task_t *);
+int mig_do_send(task_t *);
+int mig_send_hshake(task_t *, struct socket *, int);
+int mig_recv_hshake(struct socket *);
+
+int task_move_to_node(task_t *, struct sockaddr *, int);
+int task_remote_expel(task_t *);
+
+#endif /* _HPC_MIG_H */
Index: linux/include/hpc/omtask.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/omtask.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_OMTASK_H
+#define _HPC_OMTASK_H
+
+/* temporary fix for ppc */
+#ifndef NCAPINTS
+# define NCAPINTS 1
+#endif
+
+typedef struct openmosix_task {
+	volatile u32 dflags;		/* distributed flags */
+	volatile u32 stay;		/* reasons why process must stay */
+	atomic_t dreqs;			/* bits that others may request */
+	struct socket *contact;		/* DEPUTY <==> REMOTE connection */
+	struct sockaddr *whereto;	/* sockaddr to send to if DREQ_MOVE */
+
+	wait_queue_head_t wait_dist;	/* misc. wait for process */
+
+	struct list_head rfiles;	/* deputy held files */
+
+	/* the following variables are only use on remote */
+	kernel_cap_t remote_caps;	/* effective capabilities on REMOTE */
+	pid_t pid;			/* original PID */
+	pid_t tgid;			/* original TGID */
+
+	/* arch dependant */
+	u32 features[NCAPINTS];		/* CPU features on original node */
+} om_task_t;
+
+#endif /* _HPC_OMTASK_H */
Index: linux/include/hpc/proc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/proc.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_PROC_H
+#define _HPC_PROC_H
+
+int proc_pid_set_0(task_t *p, char *value, size_t size) { return -EINVAL; }
+int proc_pid_get_0(task_t *p, char *value, size_t size) { return -EINVAL; }
+int proc_admin_set_0(char *value, size_t size) { return -EINVAL; }
+int proc_admin_get_0(char *value, size_t size) { return -EINVAL; }
+
+typedef struct om_proc_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+	int (*set)(char *dummy, size_t);
+	int (*get)(char *dummy, size_t);
+} om_proc_entry_t;
+
+typedef struct om_proc_pid_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+	int (*set)(task_t *t, char *dummy, size_t);
+	int (*get)(task_t *t, char *dummy, size_t);
+} om_proc_pid_entry_t;
+
+#endif /* _HPC_PROC_H */
Index: linux/include/hpc/protocol.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/protocol.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+#ifndef _HPC_PROTOCOL_H
+#define _HPC_PROTOCOL_H
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <asm/om-protocol.h>
+
+/* Migration handshake*/
+struct omp_mig_handshake
+{
+	int type;		/* which type (look below) */
+	long version;		/* openmosix version */
+	int reason;		/* reason for mig or command */
+	int personality;	/* of process to be sent */
+};
+/* handshake types */
+#define HSHAKE_MIG_REQUEST	0x01
+#define HSHAKE_DEPUTY_PROBE	0x02
+#define HSHAKE_REPLY		0x04
+#define HSHAKE_NOTOK		0x08
+
+
+/* main structure for passing messages between
+ * DEPUTY and REMOTE. Denotes the type of request,
+ * and the length of it */
+struct omp_req
+{
+	int type;
+	int dlen;
+};
+
+#define DEP_FLG		0x100
+#define MIG_FLG		0x200
+#define REM_FLG		0x400
+#define REPLY		0x800
+
+/* commands sent during migration */
+#define MIG_MM		(MIG_FLG | 0x10)
+#define MIG_VMA		(MIG_FLG | 0x11)
+#define MIG_PAGE	(MIG_FLG | 0x12)
+#define MIG_FP		(MIG_FLG | 0x13)
+#define MIG_ARCH	(MIG_FLG | 0x14)
+#define MIG_TASK	(MIG_FLG | 0x15)
+#define MIG_ABORT	(MIG_FLG | 0x16)
+
+/* commands sent by deputy to remote */
+#define DEP_COPY_FROM_USER	(DEP_FLG | 0x01)
+#define DEP_COPY_TO_USER	(DEP_FLG | 0x02)
+#define DEP_STRNCPY_FROM_USER	(DEP_FLG | 0x03)
+#define DEP_STRNLEN_USER	(DEP_FLG | 0x04)
+#define DEP_GET_USER		(DEP_FLG | 0x05)
+#define DEP_PUT_USER		(DEP_FLG | 0x06)
+#define DEP_SIGNAL		(DEP_FLG | 0x07)
+#define DEP_COMING_HOME		(DEP_FLG | 0x10)
+
+/* commands sent by remote to deputy */
+#define REM_BRING_HOME	(REM_FLG | 0x10)
+#define REM_PAGE	(REM_FLG | 0x11)
+#define REM_SYSCALL	(REM_FLG | 0x12)
+#define REM_FORK	(REM_FLG | 0x14)
+#define REM_MMAP	(REM_FLG | 0x15)
+#define REM_EXECVE	(REM_FLG | 0x16)
+
+/* task_struct values that need to be passed */
+struct omp_mig_task
+{
+	unsigned long ptrace;
+	long nice;
+
+	kernel_cap_t caps;
+	struct rlimit rlim_cpu, rlim_data, rlim_stack, rlim_rss, rlim_as;
+
+	pid_t pid, tgid;
+	unsigned long personality;
+
+	/* process credentials */
+	uid_t uid, euid, suid, fsuid;
+	gid_t gid, egid, sgid, fsgid;
+
+	/* signals */
+	sigset_t blocked, real_blocked;
+	struct k_sigaction sighand[_NSIG];
+	unsigned long sas_ss_sp;
+	size_t sas_ss_size;
+
+	/* saved user space regs */
+	struct pt_regs regs;
+
+	struct omp_mig_arch_task arch;
+	char comm[TASK_COMM_LEN]; 
+};
+
+/* mm_struct values */
+struct omp_mig_mm
+{
+	unsigned long start_code, end_code, start_data, end_data;
+	unsigned long start_brk, brk, start_stack;
+	unsigned long arg_start, arg_end, env_start, env_end;
+};
+
+struct omp_mig_vma
+{
+	unsigned long vm_start;
+	unsigned long vm_size;
+	unsigned long vm_flags;
+	unsigned long vm_pgoff;
+	struct file *vm_file;
+	struct dentry *f_dentry;
+	loff_t i_size;
+};
+
+struct omp_syscall_req
+{
+	int n;			/* syscall number */
+	unsigned long arg[7];	/* array of arguments */
+};
+
+struct omp_syscall_ret
+{
+	long ret;		/* syscall return value */
+};
+
+struct omp_fork_req
+{
+	unsigned long clone_flags;
+	struct pt_regs regs;
+	struct sockaddr sockaddr;
+	unsigned long stack_start;
+	unsigned long stack_size;
+};
+
+struct omp_fork_ret
+{
+	pid_t pid, tgid;	/* child pid and tgid */
+};
+
+struct omp_usercopy_req
+{
+	unsigned long addr;
+	unsigned long len;
+};
+
+struct omp_usercopy_emb
+{
+	unsigned long addr;
+	unsigned long len;
+	s64 val;
+};
+
+struct omp_page_req
+{
+	struct file * file;
+	unsigned long offset;
+};
+
+struct omp_mmap_req
+{
+	unsigned long addr;
+	unsigned long len;
+	unsigned long flags;
+	unsigned long prot;
+	unsigned long fd;
+	unsigned long pgoff;
+};
+
+struct omp_execve_req
+{
+	int filelen;
+	int argc, envc;
+	int argvlen, envplen;
+	struct pt_regs regs;
+};
+
+struct omp_execve_ret
+{
+	int ret;
+};
+
+struct omp_mmap_ret
+{
+	long ret;
+	struct file * file;
+	unsigned long isize;
+};
+
+struct omp_signal
+{
+	int signr;
+	siginfo_t siginfo;
+};
+
+#endif /*  _HPC_PROTOCOL_H */
Index: linux/include/hpc/prototype.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/prototype.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_PROTOTYPE_H
+#define _HPC_PROTOTYPE_H
+
+#ifdef CONFIG_OPENMOSIX_MIGRATION_VERBOSE
+#define OM_VERBOSE_MIG(fmt...)	printk(KERN_NOTICE fmt)
+#else
+#define OM_VERBOSE_MIG(fmt...)	do { } while (0)
+#endif
+
+#define OMBUG(f, a...)	printk(KERN_ERR "[OMBUG] %s: " f, __FUNCTION__, ## a)
+
+
+NORET_TYPE void		deputy_die_on_communication(void);
+void			deputy_main_loop(void);
+void			deputy_startup(task_t *p);
+
+/*****************************************************************************/
+
+struct om_held_file
+{
+	struct list_head list;
+	struct file *file;
+	unsigned long nb;
+	struct page *(*nopage)(struct vm_area_struct *, unsigned long, int *);
+};
+
+struct rfile_inode_data
+{
+	struct file *file;
+	unsigned long node;
+	loff_t isize;
+};
+
+struct vm_operations_struct; /* forward declaration */
+
+int			task_heldfiles_add(task_t *p, struct file *file,
+					struct vm_operations_struct *vm_ops);
+void			task_heldfiles_clear(task_t *p);
+struct om_held_file *	task_heldfiles_find(task_t *p, struct file *file);
+
+struct file *		task_rfiles_get(task_t *p, struct file *file,
+					unsigned long node, loff_t isize);
+
+struct file *		rfiles_inode_get_file(struct inode *inode);
+
+/*****************************************************************************/
+
+struct omp_mig_vma; /* forward declaration */
+
+NORET_TYPE void	remote_disappear(void);
+int		remote_mmap(struct omp_mig_vma *, int);
+long		remote_do_syscall(int, struct pt_regs *);
+int		remote_do_comm(task_t *);
+long		remote_do_fork(unsigned long clone_flags,
+				unsigned long stack_start,
+				struct pt_regs *regs,
+				unsigned long stack_size,
+				int __user *parent_tidptr,
+				int __user *child_tidptr);
+long		remote_do_mmap(unsigned long addr, unsigned long len,
+				unsigned long prot, unsigned long flags,
+				unsigned long fd, unsigned long pgoff);
+int		remote_file_mmap(struct file *file,
+				struct vm_area_struct *vma);
+int		remote_readpage(struct file *file, struct page *page);
+
+#endif /* _HPC_PROTOTYPE_H */
Index: linux/include/hpc/service.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/service.h	2006-09-28 15:02:19.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_SERVICE_H
+#define _HPC_SERVICE_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+int sockaddr_to_string(struct sockaddr *address, char *buffer);
+int string_to_sockaddr(char *buf, struct sockaddr *address);
+void sockaddr_setup_port(struct sockaddr *, int port);
+int sockaddr_inherit(struct socket *mlink, struct sockaddr *sa);
+
+void om_daemonize(char *, int);
+
+#endif /* _HPC_SERVICE_H */
Index: linux/include/hpc/syscalls.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/syscalls.h	2006-09-28 15:02:20.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_SYSCALL_H
+#define _HPC_SYSCALL_H
+
+#define SYSARG(n)	arch_get_sys_arg(n, &regs)
+#define SYSNB()		arch_get_sys_nb(&regs)
+
+typedef struct syscall_parameter_t { long arg[NR_MAX_SYSCALL_ARG]; }
+						syscall_parameter_t;
+typedef long (*syscall_func_t)(syscall_parameter_t);
+
+#endif /* _HPC_SYSCALL_H */
Index: linux/include/hpc/task.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/task.h	2006-09-28 15:02:20.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_TASK_H
+#define _HPC_TASK_H
+
+#ifdef CONFIG_OPENMOSIX
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <asm/atomic.h>
+
+#define OPENMOSIX_INIT_TASK(tsk) .om = {	\
+	.dflags = 0,				\
+	.dreqs = ATOMIC_INIT(0),                \
+	.rfiles = LIST_HEAD_INIT(tsk.om.rfiles),\
+}
+
+
+#define OPENMOSIX_INIT_MM()			\
+	.mm_realusers = ATOMIC_INIT(1),		\
+
+/*
+ * distributed flags (dflags):
+ * that are *ONLY* set by the process itself, but may be read by others:
+ */
+#define	DDEPUTY		0x00000001	/* process is a DEPUTY stub */
+#define	DREMOTE		0x00000002	/* process is running remotely */
+#define	DINCOMING	0x00000040	/* process coming here */
+#define	DPASSING	0x00000080	/* process is in migration */
+#define	DFINISHED	0x00000200	/* wants to become zombie */
+#define	DREMOTEDAEMON	0x00000400	/* set DREMOTE on "fork" */
+
+#define	DMIGRATED	(DDEPUTY | DREMOTE) /* if task has been migrated */
+
+/*
+ * distributed request (dreqs):
+ * Thoses flags are set by any process to interact with the process.
+ */
+#define DREQ_MOVE	(1 << 0)	/* the process has to move */
+#define	DREQ_CHECKSTAY	(1 << 1)	/* check whether still stay */
+#define	DREQ_URGENT	(1 << 2)	/* something urgent (R=>D) */
+
+/*
+ * stay reason (dstay):
+ */
+#define	DSTAY_MONKEY	(1 << 0)	/* using monkey vnode */
+#define	DSTAY_DEV	(1 << 1)	/* mapping a device */
+#define	DSTAY_86	(1 << 2)	/* running in 86 mode */
+#define	DSTAY_PRIV	(1 << 4)	/* privilleged inst. access (in/out) */
+#define	DSTAY_MLOCK	(1 << 5)	/* has locked memory */
+#define	DSTAY_CLONE	(1 << 6)	/* shared VM, eliminate this once DSM*/
+#define	DSTAY_RT	(1 << 7)	/* Real-Time scheduling */
+#define	DSTAY_IOPL	(1 << 8)	/* direct I/O permission */
+#define	DSTAY_SYSTEM	(1 << 9)	/* init process */
+#define	DSTAY_OTHER1	(1 << 24)	/* external reason for stay (1) */
+#define	DSTAY_OTHER2	(1 << 25)	/* external reason for stay (2) */
+#define	DSTAY_OTHER3	(1 << 26)	/* external reason for stay (3) */
+#define	DSTAY_OTHER4	(1 << 27)	/* external reason for stay (4) */
+#define	DNOMIGRATE	(1 << 31)	/* user requested no auto-migrations */
+
+#define	DSTAY		(~DNOMIGRATE)
+#define	DSTAY_PER_MM	(DSTAY_MONKEY|DSTAY_DEV|DSTAY_MLOCK)
+
+int task_set_where(struct task_struct *p, int value);
+int task_get_where(struct task_struct *p);
+
+/* dreqs */
+static inline void task_set_dreqs(struct task_struct *p, unsigned int val)
+{
+	atomic_set_mask(val, &p->om.dreqs);
+}
+
+static inline void task_clear_dreqs(struct task_struct *p, unsigned int val)
+{
+	atomic_clear_mask(val, &p->om.dreqs);
+}
+
+static inline int task_test_dreqs(struct task_struct *p, unsigned int val)
+{
+	return atomic_read(&p->om.dreqs) & val;
+}
+
+/* dflags */
+
+static inline void task_set_dflags(struct task_struct *p, unsigned int val)
+{
+	p->om.dflags |= val;
+}
+
+static inline void task_clear_dflags(struct task_struct *p, unsigned int val)
+{
+	p->om.dflags &= ~val;
+}
+
+static inline int task_test_dflags(struct task_struct *p, unsigned int val)
+{
+	return (p->om.dflags & val);
+}
+
+/* stay */
+
+static inline void task_set_stay(struct task_struct *p, unsigned int val)
+{
+	p->om.stay |= val;
+}
+
+static inline void task_clear_stay(struct task_struct *p, unsigned int val)
+{
+	p->om.stay &= ~val;
+}
+
+static inline int task_test_stay(struct task_struct *p, unsigned int val)
+{
+	return (p->om.stay & val);
+}
+
+#define task_dreqs_pending(p)	task_test_dreqs(p, ~0)
+
+void task_add_balance_reason(struct task_struct *p, int w);
+
+int task_go_home(struct task_struct *p);
+int task_go_home_for_reason(struct task_struct *p, int reason);
+
+int task_check_stay(struct task_struct *p);
+void task_do_request(void);
+
+struct sockaddr;
+int task_register_migration(task_t *p, struct sockaddr *);
+
+struct inode;
+int task_maps_inode(task_t *p, struct inode *);
+
+#else
+
+#define OPENMOSIX_INIT_TASK(tsk)	/* */
+#define OPENMOSIX_INIT_MM()		/* */
+
+#endif
+#endif /* _HPC_HPCTASK_H */
Index: linux/include/hpc/uaccess.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/uaccess.h	2006-09-28 15:02:20.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_UACCESS_H
+#define _HPC_UACCESS_H
+
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/task.h>
+
+unsigned long	deputy_copy_from_user(void *to,
+					const void __user *from,
+					unsigned long n);
+unsigned long	deputy_copy_to_user(void __user *to,
+					const void *from,
+					unsigned long n);
+unsigned long	deputy_strncpy_from_user(char *dst, const char __user *src,
+							long count);
+unsigned long	deputy_strnlen_user(const char *s, long n);
+
+long		deputy_put_user(long value, const void *addr, size_t size);
+long		deputy_get_user(long *value, const void *addr, size_t size);
+
+#if BITS_PER_LONG < 64
+long		deputy_get_user64(s64 *value, const void *addr);
+long		deputy_put_user64(s64 value, const void *addr);
+#endif
+
+/**
+ * openmosix_memory_away - Test is memory is here
+ **/
+static inline int openmosix_memory_away(void)
+{
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (task_test_dflags(current, DDEPUTY))
+		return 1;
+	return 0;
+}
+
+#else
+
+#define openmosix_memory_away() 0
+#define deputy_put_user(a, b, c) 0
+#define deputy_get_user(a, b, c) 0
+
+#endif
+
+#endif /* _HPC_UACCESS_H */
Index: linux/include/hpc/version.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/hpc/version.h	2006-09-28 15:02:20.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *	Copyright (C) 2005-2006 Vincent Hanquez <vincent@snarc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez and Alexander Nyberg
+ *
+ */
+
+#ifndef _HPC_VERSION_H
+#define _HPC_VERSION_H
+
+#define OPENMOSIX_VERSION_MAJOR		0
+#define OPENMOSIX_VERSION_MINOR		0
+#define OPENMOSIX_VERSION_MICRO		0
+
+#define OPENMOSIX_VERSION	(OPENMOSIX_VERSION_MAJOR * 10000) + \
+				(OPENMOSIX_VERSION_MINOR * 100) + \
+				(OPENMOSIX_VERSION_MICRO)
+
+#define OPENMOSIX_VERSION_TUPPLE \
+				OPENMOSIX_VERSION_MAJOR, \
+				OPENMOSIX_VERSION_MINOR, \
+				OPENMOSIX_VERSION_MICRO
+
+/* FIXME : need to create a scheme about version handling */
+#define OPENMOSIX_VERSION_BALANCE	0x1L
+#define OPENMOSIX_VERSION_MIGRATION	0x1L
+
+#endif /* _HPC_VERSION_H */
Index: linux/include/linux/compiler.h
===================================================================
--- linux.orig/include/linux/compiler.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/linux/compiler.h	2006-09-28 15:02:20.000000000 +0200
@@ -36,6 +36,18 @@
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_OPENMOSIX
+#define OM_NSTATIC
+#else
+#define OM_NSTATIC static
+#endif
+
+#ifdef CONFIG_KCOMD
+#define KCOMD_NSTATIC
+#else
+#define KCOMD_NSTATIC static
+#endif
+
 #if __GNUC__ > 4
 #error no compiler-gcc.h file for this gcc version
 #elif __GNUC__ == 4
Index: linux/include/linux/hpc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/linux/hpc.h	2006-09-28 15:02:20.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ *	Copyright (C) 2002-2004 Moshe Bar <moshe@moshebar.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * Original Mosix code Copyright (C) Amnon Barak, Amnon Shiloh
+ *
+ * Changes for 2.6 by Vincent Hanquez
+ *
+ */
+
+#ifndef _LINUX_HPC_H
+#define _LINUX_HPC_H
+
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/hpc.h>
+#include <hpc/task.h>
+#define OM_MM(task)		(task->mm)
+#else
+#define OM_MM(task)		(1)
+
+#endif
+
+#endif /* _LINUX_HPC_H */
Index: linux/include/linux/init_task.h
===================================================================
--- linux.orig/include/linux/init_task.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/linux/init_task.h	2006-09-28 15:02:20.000000000 +0200
@@ -3,9 +3,10 @@
 
 #include <linux/file.h>
 #include <linux/rcupdate.h>
+#include <hpc/task.h>
 
 #define INIT_FDTABLE \
-{							\
+{ 							\
 	.max_fds	= NR_OPEN_DEFAULT, 		\
 	.max_fdset	= EMBEDDED_FD_SET_SIZE,		\
 	.fd		= &init_files.fd_array[0], 	\
@@ -51,6 +52,7 @@
 	.page_table_lock =  SPIN_LOCK_UNLOCKED, 		\
 	.mmlist		= LIST_HEAD_INIT(name.mmlist),		\
 	.cpu_vm_mask	= CPU_MASK_ALL,				\
+	OPENMOSIX_INIT_MM()					\
 }
 
 #define INIT_SIGNALS(sig) {	\
@@ -123,6 +125,7 @@
 	.journal_info	= NULL,						\
 	.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
 	.fs_excl	= ATOMIC_INIT(0),				\
+	OPENMOSIX_INIT_TASK(tsk)					\
 }
 
 
Index: linux/include/linux/net.h
===================================================================
--- linux.orig/include/linux/net.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/linux/net.h	2006-09-28 15:02:20.000000000 +0200
@@ -183,6 +183,9 @@
 extern int	     sock_wake_async(struct socket *sk, int how, int band);
 extern int	     sock_register(struct net_proto_family *fam);
 extern int	     sock_unregister(int family);
+#ifdef CONFIG_KCOMD
+extern struct socket *sock_alloc(void);
+#endif
 extern int	     sock_create(int family, int type, int proto,
 				 struct socket **res);
 extern int	     sock_create_kern(int family, int type, int proto,
Index: linux/include/linux/sched.h
===================================================================
--- linux.orig/include/linux/sched.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/linux/sched.h	2006-09-28 15:02:20.000000000 +0200
@@ -37,6 +37,10 @@
 #include <linux/rcupdate.h>
 #include <linux/futex.h>
 
+#ifdef CONFIG_OPENMOSIX
+#include <hpc/omtask.h>
+#endif /* CONFIG_OPENMOSIX */
+
 #include <linux/auxvec.h>	/* For AT_VECTOR_SIZE */
 
 struct exec_domain;
@@ -350,6 +354,10 @@
 	/* aio bits */
 	rwlock_t		ioctx_list_lock;
 	struct kioctx		*ioctx_list;
+
+#ifdef CONFIG_OPENMOSIX
+	atomic_t mm_realusers;		/* nb of processes that uses this mm */
+#endif /* CONFIG_MOSIX */
 };
 
 struct sighand_struct {
@@ -866,6 +874,9 @@
 	u64 acct_vm_mem1;	/* accumulated virtual memory usage */
 	clock_t acct_stimexpd;	/* clock_t-converted stime since last update */
 #endif
+#ifdef CONFIG_OPENMOSIX
+	om_task_t om;
+#endif /* CONFIG_OPENMOSIX */
 #ifdef CONFIG_NUMA
   	struct mempolicy *mempolicy;
 	short il_next;
Index: linux/include/linux/signal.h
===================================================================
--- linux.orig/include/linux/signal.h	2006-09-28 15:02:04.000000000 +0200
+++ linux/include/linux/signal.h	2006-09-28 15:02:20.000000000 +0200
@@ -260,7 +260,7 @@
 }
 
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
-extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+extern int __group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 
Index: linux/kernel/exit.c
===================================================================
--- linux.orig/kernel/exit.c	2006-09-28 15:02:04.000000000 +0200
+++ linux/kernel/exit.c	2006-09-28 15:02:20.000000000 +0200
@@ -1,4 +1,5 @@
 /*
+
  *  linux/kernel/exit.c
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
@@ -42,13 +43,15 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <linux/hpc.h>
+
+OM_NSTATIC void exit_mm(struct task_struct * tsk);
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
 int getrusage(struct task_struct *, int, struct rusage __user *);
 
-static void exit_mm(struct task_struct * tsk);
-
 static void __unhash_process(struct task_struct *p)
 {
 	nr_threads--;
@@ -283,7 +286,7 @@
  *
  * NOTE that reparent_to_init() gives the caller full capabilities.
  */
-static void reparent_to_init(void)
+OM_NSTATIC void reparent_to_init(void)
 {
 	write_lock_irq(&tasklist_lock);
 
@@ -553,10 +556,13 @@
  * Turn us into a lazy TLB process if we
  * aren't already..
  */
-static void exit_mm(struct task_struct * tsk)
+OM_NSTATIC void exit_mm(struct task_struct * tsk)
 {
 	struct mm_struct *mm = tsk->mm;
 
+#ifdef CONFIG_OPENMOSIX
+	if (!task_test_dflags(tsk, DDEPUTY))
+#endif
 	mm_release(tsk, mm);
 	if (!mm)
 		return;
@@ -891,6 +897,9 @@
 		update_hiwater_rss(tsk->mm);
 		update_hiwater_vm(tsk->mm);
 	}
+#ifdef CONFIG_OPENMOSIX
+	openmosix_task_exit();
+#endif
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead) {
  		hrtimer_cancel(&tsk->signal->real_timer);
Index: linux/kernel/fork.c
===================================================================
--- linux.orig/kernel/fork.c	2006-09-28 15:02:04.000000000 +0200
+++ linux/kernel/fork.c	2006-09-28 15:02:20.000000000 +0200
@@ -52,6 +52,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#include <linux/hpc.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -315,6 +317,9 @@
 {
 	atomic_set(&mm->mm_users, 1);
 	atomic_set(&mm->mm_count, 1);
+#ifdef CONFIG_OPENMOSIX
+	atomic_set(&mm->mm_realusers, 1);
+#endif /* CONFIG_OPENMOSIX */
 	init_rwsem(&mm->mmap_sem);
 	INIT_LIST_HEAD(&mm->mmlist);
 	mm->core_waiters = 0;
@@ -473,6 +478,9 @@
 	err = dup_mmap(mm, oldmm);
 	if (err)
 		goto free_pt;
+#ifdef CONFIG_OPENMOSIX
+	task_clear_stay(tsk, DSTAY_CLONE);
+#endif /* CONFIG_OPENMOSIX */
 
 	mm->hiwater_rss = get_mm_rss(mm);
 	mm->hiwater_vm = mm->total_vm;
@@ -517,6 +525,9 @@
 
 	if (clone_flags & CLONE_VM) {
 		atomic_inc(&oldmm->mm_users);
+#ifdef CONFIG_OPENMOSIX
+		atomic_inc(&oldmm->mm_realusers);
+#endif /* CONFIG_OPENMOSIX */
 		mm = oldmm;
 		goto good_mm;
 	}
@@ -1045,6 +1056,10 @@
 		goto bad_fork_cleanup_policy;
 	if ((retval = audit_alloc(p)))
 		goto bad_fork_cleanup_security;
+#ifdef CONFIG_OPENMOSIX
+	if ((retval = openmosix_task_init(p)))
+		goto bad_fork_cleanup_audit;
+#endif /* CONFIG_OPENMOSIX */
 	/* copy all the process information */
 	if ((retval = copy_semundo(clone_flags, p)))
 		goto bad_fork_cleanup_audit;
@@ -1308,17 +1323,20 @@
 {
 	struct task_struct *p;
 	int trace = 0;
-	struct pid *pid = alloc_pid();
-	long nr;
-
-	if (!pid)
+ 	struct pid *pid = alloc_pid();
+ 	long nr;
+ 
+ 	if (!pid)
 		return -EAGAIN;
-	nr = pid->nr;
+ 	nr = pid->nr;
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
 		if (trace)
 			clone_flags |= CLONE_PTRACE;
 	}
+#ifdef CONFIG_OPENMOSIX
+	openmosix_pre_clone(clone_flags);
+#endif
 
 	p = copy_process(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr, nr);
 	/*
@@ -1360,6 +1378,9 @@
 		free_pid(pid);
 		nr = PTR_ERR(p);
 	}
+#ifdef CONFIG_OPENMOSIX
+	openmosix_post_clone(clone_flags);
+#endif
 	return nr;
 }
 
Index: linux/kernel/sched.c
===================================================================
--- linux.orig/kernel/sched.c	2006-09-28 15:02:04.000000000 +0200
+++ linux/kernel/sched.c	2006-09-28 15:02:20.000000000 +0200
@@ -355,7 +355,7 @@
  * interrupts.  Note the ordering: we can safely lookup the task_rq without
  * explicitly disabling preemption.
  */
-static inline runqueue_t *task_rq_lock(task_t *p, unsigned long *flags)
+OM_NSTATIC runqueue_t *task_rq_lock(task_t *p, unsigned long *flags)
 	__acquires(rq->lock)
 {
 	struct runqueue *rq;
@@ -371,7 +371,7 @@
 	return rq;
 }
 
-static inline void task_rq_unlock(runqueue_t *rq, unsigned long *flags)
+OM_NSTATIC inline void task_rq_unlock(runqueue_t *rq, unsigned long *flags)
 	__releases(rq->lock)
 {
 	spin_unlock_irqrestore(&rq->lock, *flags);
Index: linux/MAINTAINERS
===================================================================
--- linux.orig/MAINTAINERS	2006-09-28 15:02:04.000000000 +0200
+++ linux/MAINTAINERS	2006-09-28 15:02:20.000000000 +0200
@@ -2081,6 +2081,15 @@
 L:	linux-scsi@vger.kernel.org
 S:	Maintained
 
+OPENMOSIX
+P:	Vincent Hanquez
+M:	tab@snarc.org
+P:	Alexander Nyberg
+M:	alexn@telia.com
+L:	openmosix-general@lists.sourceforge.net
+W:	http://openmosix.sourceforge.net/
+S:	Maintained
+
 OPL3-SA2, SA3, and SAx DRIVER
 P:	Zwane Mwaikambo
 M:	zwane@arm.linux.org.uk
Index: linux/Makefile
===================================================================
--- linux.orig/Makefile	2006-09-28 15:02:04.000000000 +0200
+++ linux/Makefile	2006-09-28 15:02:20.000000000 +0200
@@ -311,7 +311,7 @@
 
 # Read KERNELRELEASE from .kernelrelease (if it exists)
 KERNELRELEASE = $(shell cat .kernelrelease 2> /dev/null)
-KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)-om
 
 export	VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION \
 	ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC \
@@ -463,6 +463,9 @@
 # Defaults vmlinux but it is usually overriden in the arch makefile
 all: vmlinux
 
+unsparse:
+	scripts/unsparse
+
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 CFLAGS		+= -Os
 else
@@ -518,7 +521,7 @@
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/ hpc/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
Index: linux/mm/mlock.c
===================================================================
--- linux.orig/mm/mlock.c	2006-09-28 15:02:04.000000000 +0200
+++ linux/mm/mlock.c	2006-09-28 15:02:20.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/mempolicy.h>
 #include <linux/syscalls.h>
 
+#include <linux/hpc.h>
 
 static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
 	unsigned long start, unsigned long end, unsigned int newflags)
@@ -20,7 +21,7 @@
 	int pages;
 	int ret = 0;
 
-	if (newflags == vma->vm_flags) {
+ 	if (newflags == vma->vm_flags) {
 		*prev = vma;
 		goto out;
 	}
@@ -143,6 +144,10 @@
 	/* check against resource limits */
 	if ((locked <= lock_limit) || capable(CAP_IPC_LOCK))
 		error = do_mlock(start, len, 1);
+#ifdef CONFIG_OPENMOSIX
+	if (!error) /* FIXME len == 0 shouldn't DSTAY MLOCK current & clones */
+		stay_me_and_my_clones(DSTAY_MLOCK);
+#endif /* CONFIG_OPENMOSIX */
 	up_write(&current->mm->mmap_sem);
 	return error;
 }
@@ -156,6 +161,10 @@
 	start &= PAGE_MASK;
 	ret = do_mlock(start, len, 0);
 	up_write(&current->mm->mmap_sem);
+#ifdef CONFIG_OPENMOSIX
+	if (ret)
+		unstay_mm(current->mm);
+#endif /* CONFIG_OPENMOSIX */
 	return ret;
 }
 
@@ -205,6 +214,10 @@
 	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
 	    capable(CAP_IPC_LOCK))
 		ret = do_mlockall(flags);
+#ifdef CONFIG_OPENMOSIX
+	if (!ret)
+		stay_me_and_my_clones(DSTAY_MLOCK);
+#endif /* CONFIG_OPENMOSIX */
 	up_write(&current->mm->mmap_sem);
 out:
 	return ret;
@@ -217,9 +230,12 @@
 	down_write(&current->mm->mmap_sem);
 	ret = do_mlockall(0);
 	up_write(&current->mm->mmap_sem);
+#ifdef CONFIG_OPENMOSIX
+	if (ret)
+		unstay_mm(current->mm);
+#endif /* CONFIG_OPENMOSIX */
 	return ret;
 }
-
 /*
  * Objects with different lifetime than processes (SHM_LOCK and SHM_HUGETLB
  * shm segments) get accounted against the user_struct instead.
Index: linux/mm/mmap.c
===================================================================
--- linux.orig/mm/mmap.c	2006-09-28 15:02:05.000000000 +0200
+++ linux/mm/mmap.c	2006-09-28 15:02:21.000000000 +0200
@@ -30,6 +30,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlb.h>
 
+#include <linux/hpc.h>
+
 static void unmap_region(struct mm_struct *mm,
 		struct vm_area_struct *vma, struct vm_area_struct *prev,
 		unsigned long start, unsigned long end);
@@ -183,9 +185,22 @@
 
 	flush_dcache_mmap_lock(mapping);
 	if (unlikely(vma->vm_flags & VM_NONLINEAR))
+	{
 		list_del_init(&vma->shared.vm_set.list);
+#ifdef CONFIG_OPENMOSIX
+		if (list_empty(&vma->shared.vm_set.list))
+			openmosix_no_longer_monkey(file->f_dentry->d_inode);
+#endif /* CONFIG_OPENMOSIX */
+	}
 	else
+	{
 		vma_prio_tree_remove(vma, &mapping->i_mmap);
+#ifdef CONFIG_OPENMOSIX
+		/* FIXME tab: maybe wrong ! */
+		if (vma->shared.vm_set.parent && vma->shared.vm_set.head)
+			openmosix_no_longer_monkey(file->f_dentry->d_inode);
+#endif /* CONFIG_OPENMOSIX */
+	}
 	flush_dcache_mmap_unlock(mapping);
 }
 
@@ -888,6 +903,9 @@
 	struct rb_node ** rb_link, * rb_parent;
 	int accountable = 1;
 	unsigned long charged = 0, reqprot = prot;
+#ifdef CONFIG_OPENMOSIX
+	int stay_reason = 0;
+#endif /* CONFIG_OPENMOSIX */
 
 	if (file) {
 		if (is_file_hugepages(file))
@@ -923,7 +941,7 @@
                return -EOVERFLOW;
 
 	/* Too many mappings? */
-	if (mm->map_count > sysctl_max_map_count)
+	if (OM_MM(current) && mm->map_count > sysctl_max_map_count)
 		return -ENOMEM;
 
 	/* Obtain the address to map to. we verify (or select) it and ensure
@@ -938,7 +956,7 @@
 	 * of the memory object, so we don't do any here.
 	 */
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
-			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
+			(OM_MM(current) ? mm->def_flags : 0) | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
 	if (flags & MAP_LOCKED) {
 		if (!can_do_mlock())
@@ -946,7 +964,7 @@
 		vm_flags |= VM_LOCKED;
 	}
 	/* mlock MCL_FUTURE? */
-	if (vm_flags & VM_LOCKED) {
+	if (OM_MM(current) && vm_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = len >> PAGE_SHIFT;
 		locked += mm->locked_vm;
@@ -980,9 +998,19 @@
 			vm_flags |= VM_SHARED | VM_MAYSHARE;
 			if (!(file->f_mode & FMODE_WRITE))
 				vm_flags &= ~(VM_MAYWRITE | VM_SHARED);
+#ifdef CONFIG_OPENMOSIX
+			if (file->f_mode & FMODE_WRITE)
+				stay_reason |= DSTAY_MONKEY;
+#endif /* CONFIG_OPENMOSIX */
 
 			/* fall through */
 		case MAP_PRIVATE:
+#ifdef CONFIG_OPENMOSIX
+			if (inode && inode->i_mapping->i_mmap_writable != 0)
+				stay_reason |= DSTAY_MONKEY;
+			if (S_ISCHR(file->f_dentry->d_inode->i_mode))
+				stay_reason |= DSTAY_DEV;
+#endif /* CONFIG_OPENMOSIX */
 			if (!(file->f_mode & FMODE_READ))
 				return -EACCES;
 			break;
@@ -1009,6 +1037,10 @@
 	error = security_file_mmap(file, reqprot, prot, flags);
 	if (error)
 		return error;
+#ifdef CONFIG_OPENMOSIX
+	if (file && task_test_dflags(current, DDEPUTY))
+		return deputy_do_mmap_pgoff(file, addr, len, prot, vm_flags, pgoff);
+#endif
 		
 	/* Clear old maps */
 	error = -ENOMEM;
@@ -1128,6 +1160,10 @@
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
 	}
+#ifdef CONFIG_OPENMOSIX
+	if (stay_reason)
+		stay_me_and_my_clones(stay_reason);
+#endif /* CONFIG_OPENMOSIX */
 	if (flags & MAP_POPULATE) {
 		up_write(&mm->mmap_sem);
 		sys_remap_file_pages(addr, len, 0,
@@ -1339,18 +1375,22 @@
 		unsigned long pgoff, unsigned long flags)
 {
 	unsigned long ret;
-
+  
 	if (!(flags & MAP_FIXED)) {
 		unsigned long (*get_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
-
+  
 		get_area = current->mm->get_unmapped_area;
+#ifdef CONFIG_OPENMOSIX
+		if (task_test_dflags(current, DDEPUTY))
+			return PAGE_ALIGN(addr);
+#endif
 		if (file && file->f_op && file->f_op->get_unmapped_area)
 			get_area = file->f_op->get_unmapped_area;
 		addr = get_area(file, addr, len, pgoff, flags);
 		if (IS_ERR_VALUE(addr))
 			return addr;
 	}
-
+  
 	if (addr > TASK_SIZE - len)
 		return -ENOMEM;
 	if (addr & ~PAGE_MASK)
Index: linux/net/socket.c
===================================================================
--- linux.orig/net/socket.c	2006-09-28 15:02:05.000000000 +0200
+++ linux/net/socket.c	2006-09-28 15:02:21.000000000 +0200
@@ -511,7 +511,7 @@
  *	NULL is returned.
  */
 
-static struct socket *sock_alloc(void)
+KCOMD_NSTATIC struct socket *sock_alloc(void)
 {
 	struct inode * inode;
 	struct socket * sock;
@@ -530,6 +530,9 @@
 	put_cpu_var(sockets_in_use);
 	return sock;
 }
+#ifdef CONFIG_KCOMD
+EXPORT_SYMBOL_GPL(sock_alloc);
+#endif
 
 /*
  *	In theory you can't get an open on this inode, but /proc provides
