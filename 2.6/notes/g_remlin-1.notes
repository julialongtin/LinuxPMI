= The 2.6.28.7 forward port, by g_remlin =

== patch 001 - arch/x86/include/asm/pms_32.h ==

=== Summary ===
This file contains architecture specific helper functions used by the system call redirection subsystem, as well as a helper for the process teardown/buildup code. It is included by arch/x86/include/asm/pms.h. ^[fixme6][fixme7][fixme8]^

=== Details ===
First, we define the maximum number of arguments a system call can be passed on this architecture, which is 6.

'arch_get_sys_arg' is defined as an inline function. It is called by hpc/remote.c's remote_do_syscall directly, and wrapped by include/hpc/syscalls.h's SYSARG macro, which is used by hpc/syscalls.c's pms_sys_execve. Its purpose is to return the N'th argument passed into the syscall that inlines us. Since our arguments are stored in order in the pt_regs structure passed into syscalls, arch_get_sys_arg simply returns (as a long) the N'th long-sized value in the passed in pt_regs. If we are asked for an argument index greater than or equal to the maximum system call argument defined earlier, we BUG_ON() about it.

arch_get_sys_nb is defined as an inline function. It is wrapped by include/hpc/syscall.h's SYSNB macro, and called by pms_sys_remote to return the system call number of the system call request we're currently handling. On i386, this is stored in the 'ax' register, so we simply return the 'ax' member of the passed in pt_regs structure. 

[fixme1] Finally, we create ARCH_TASK_GET_USER_REGS[fixme2][fixme3], which is a macro to get the user registers of the current task, called by hpc/arch-i386.c's arch_mig_receive_proc_context, arch_mig_send_proc_context, arch_kickstart, and arch_do_signal, along with hpc/debug-i386.c's pms_debug_regs, and show_user_registers. It functions similarly to include/asm-i386/processor.h's task_pt_regs, returning the current processes registers, instead of the one of the task passed in. In it, we use current_thread to get the current task's thread structure address, add THREAD_SIZE to point to the next page in memory past it, deduct 8 so that we skip over the space on the stack that is *sometimes* updated with the SS/ESP registers, and deduct 1, returning what we've calculated as a pt_regs pointer.

== patch 002 - arch/x86/include/asm/pms_64.h ==

=== Summary ===
This file contains architecture specific helper functions used by the system call redirection subsystem, as well as a helper for the process teardown/buildup code. It is included by arch/x86/include/asm/pms.h. ^[fixme6][fixme7][fixme8]^

=== Details ===
First we define arch_get_sys_arg, an inline function. It is called by hpc/remote.c's remote_do_syscall directly, and wrapped by include/hpc/syscalls.h's SYSARG macro, which is used by hpc/syscalls.c's pms_sys_execve. Its purpose is to return the N'th argument passed into the syscall that inlines us. In it, we pull the appropriate argument from the passed in pt_regs structure, [fixme5]confirming to the order in [note1]the AMD64 ABI, and the kernel's entry.S. If we are asked for an argument index greater than the sixth, we [fixme4]BUG() about it.

arch_get_sys_nb is defined as an inline function. It is wrapped by include/hpc/syscall.h's SYSNB macro, and called by pms_sys_remote to return the system call number of the system call request we're currently handling. On x86_64, this is stored in the 'rax' register, so we simply return the lower 32bits of the 'rax' member of the passed in pt_regs structure.

Next, we define the maximum number of arguments a system call can be passed on this architecture, which is 6, per entry.S.

Finally, we create ARCH_TASK_GET_USER_REGS^[fixme2][fixme3]^, which is a macro to get the user registers of the current task. Its called by hpc/arch-x86_64.c's arch_mig_receive_proc_context, arch_mig_send_proc_context, arch_kickstart, and arch_do_signal, along with hpc/debug-x86_64.c's pms_debug_regs, and show_user_registers. It functions similarly to include/asm-i386/processor.h's task_pt_regs[fixme9], returning the current processes registers, instead of the one of the task passed in. In it, we use current_thread to get the current task's thread structure address, add THREAD_SIZE to point to the next page in memory past it[fixme10], and deduct 1, returning what we've calculated as a pt_regs pointer.

== patch 003 - arch/x86/include/asm/pms.h ==

=== Summary ===
This file contains logic for including either pms_32.h or pms_64.h, depending on whether we are compiling for an i386, or an AMD64. ^[fixme6][fixme7]^

=== Details ===
This header includes either pms_64.h or pms_32.h, depending on whether we're compiling for an i386, or an amd64.

== Notes and Comments ==
[[fixme1]]
^[fixme1]^extra whitespace here.
[[fixme2]]
^[fixme2]^unused argument.
[[fixme3]]
^[fixme3]^replace code using this with a task* with processor.h's task_pt_regs.
[[fixme4]]
^[fixme4]^why BUG on x86_64, and BUG_ON on i386?
[[fixme5]]
^[fixme5]^we screw this up, and are using RCX instead of r10. RCX is userspace, r10 is kernelspace.
[[fixme6]]
^[fixme6]^wrapper define is wrong.
[[fixme7]]
^[fixme7]^rename tmig, not pms.
[[fixme8]]
^[fixme8]^re-sequence these two files so that the code sequence matches, for comparitive purposes.
[[fixme9]]
^[fixme9]^this is *completely* wrong for x86_64. examine asm-x86_64/procesor.h's task_pt_regs macro.]
[[fixme10]]
^[fixme10]^we forget to deduct 8 here!
[[note1]]
^[note1]^http://www.x86-64.org/documentation/abi.pdf version 0.99.
